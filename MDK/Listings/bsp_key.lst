C51 COMPILER V9.60.0.0   BSP_KEY                                                           11/18/2022 17:04:36 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BSP_KEY
OBJECT MODULE PLACED IN .\Objects\bsp_key.obj
COMPILER INVOKED BY: D:\keil5\C51\BIN\C51.EXE ..\BSP\bsp_key\bsp_key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\BSP;..\BSP\bsp
                    -_key) DEBUG OBJECTEXTEND PRINT(.\Listings\bsp_key.lst) OBJECT(.\Objects\bsp_key.obj)

line level    source

   1          /*
   2           * @Author: liubotao
   3           * @Date: 2022-11-18 00:13:48
   4           * @LastEditors: liubotao
   5           * @LastEditTime: 2022-11-18 16:59:31
   6           * @FilePath: \test51\BSP\bsp_key\bsp_key.c
   7           * @Description: 矩阵按键检测
   8           * 
   9           */
  10          #include "bsp.h"
  11          #define keyboard P1
  12          
  13          sbit key_1= P3^1;
  14          sbit key_2 =P3^2;
  15          
  16          #define keyUncertainTime 3//消抖时间 ( x10 ms)
  17          
  18          int KeyValue; //全局函数，键值
  19          
  20          unsigned char code KEY_TABLE[] =
  21           {
  22                   0xEE, 0xED, 0xEB, 0xE7,
  23               0xDE, 0xDD, 0xDB, 0xBB,
  24               0xBE, 0xBD, 0xBB, 0xB7,
  25               0x7E, 0x7D, 0x7B, 0x77
  26           };
  27          
  28          int matrixKeyScan_1()//还没加消抖
  29          {
  30   1              unsigned char num = 0;
  31   1              unsigned int buffer = 0;
  32   1              
  33   1              for (num = 0; num < 4; num++)
  34   1              {
  35   2                      if (num)
  36   2                              buffer = buffer << 4;
  37   2                      keyboard = ~(0x80 >> num);
  38   2                      buffer |= (keyboard & 0x0f);
  39   2              }
  40   1              num = 16;
  41   1              while (num--)
  42   1              {
  43   2                      if (((buffer >> num) & 0x01) == 0)
  44   2                      {
  45   3                              KeyValue = num;
  46   3                              break;
  47   3                      }
  48   2              }
  49   1              return KeyValue;
  50   1      }
  51          /*
  52          检测到按键被按下时，将行扫描的结果存入临时变量，再进行列扫描，得到的结果和临时变量进行或运算。
  53          扫描完得到结果后遍历数组，找到对应的编码位置并显示数码管编码
  54          */
C51 COMPILER V9.60.0.0   BSP_KEY                                                           11/18/2022 17:04:36 PAGE 2   

  55          int matrixKeyScan_2()
  56          {
  57   1              static unsigned int keyDelayTime;
  58   1              unsigned int temp, key, i;
  59   1              keyboard = 0xF0;
  60   1              if (keyboard != 0xF0)
  61   1              {
  62   2                      keyDelayTime++;
  63   2                      if (keyDelayTime > 3)
  64   2                      {
  65   3                              temp = keyboard;
  66   3                              keyboard = 0x0F;
  67   3                              key = temp | keyboard;
  68   3                              for (i = 0; i < 16; ++i)
  69   3                              {
  70   4                                      if (key == KEY_TABLE[i])
  71   4                                              break;
  72   4                              }
  73   3                              KeyValue = i;
  74   3                              return KeyValue;
  75   3                      }
  76   2                      else return -1;
  77   2              }
  78   1              else
  79   1              {
  80   2                      keyDelayTime = 0;
  81   2                      return -1;
  82   2              }
  83   1      }
  84          
  85          int matrixKeyScan_3()
  86          {
  87   1              static unsigned int  keyDelayTime;
  88   1              keyboard=0x0f;
  89   1              if(keyboard!=0x0f)
  90   1              {
  91   2                      keyDelayTime++;
  92   2                      if(keyDelayTime>3)
  93   2                      {       
  94   3                              keyboard=0X0F;
  95   3                              switch(keyboard)
  96   3                              {
  97   4                                      case(0X0E):     KeyValue=0;break; 
  98   4                                      case(0X0D):     KeyValue=1;break; 
  99   4                                      case(0X0B): KeyValue=2;break; 
 100   4                                      case(0X07):     KeyValue=3;break; 
 101   4                              }
 102   3                              keyboard=0XF0;                          
 103   3                              switch(keyboard)
 104   3                              {
 105   4                                      case(0XE0):     KeyValue=KeyValue;break;  
 106   4                                      case(0XD0):     KeyValue=KeyValue+4;break;
 107   4                                      case(0XB0): KeyValue=KeyValue+8;break;
 108   4                                      case(0X70):     KeyValue=KeyValue+12;break;
 109   4                              }               
 110   3                      }
 111   2                      return KeyValue;
 112   2              }
 113   1              else
 114   1              {
 115   2                      keyDelayTime = 0;
 116   2                      return -1;  
C51 COMPILER V9.60.0.0   BSP_KEY                                                           11/18/2022 17:04:36 PAGE 3   

 117   2              }
 118   1              
 119   1      }
 120          static unsigned char IsKeyDown1(void) {if ((key_1) == 0) return 1;else return 0;}
 121          static unsigned char IsKeyDown2(void) {if ((key_2) == 0) return 1;else return 0;}
 122          
 123          static KEY_T s_tBtn[KEY_COUNT] = {0};
 124          static KEY_FIFO_T s_tKey;               /* 按键FIFO变量,结构体 */
 125          
 126          
 127          void bsp_PutKey(unsigned char _KeyCode)
 128          {
 129   1              s_tKey.Buf[s_tKey.Write] = _KeyCode;
 130   1      
 131   1              if (++s_tKey.Write  >= KEY_FIFO_SIZE)
 132   1              {
 133   2                      s_tKey.Write = 0;
 134   2              }
 135   1      }
 136          
 137          unsigned char bsp_GetKey(void)
 138          {
 139   1              unsigned char ret;
 140   1      
 141   1              if (s_tKey.Read == s_tKey.Write)
 142   1              {
 143   2                      return KEY_NONE;
 144   2              }
 145   1              else
 146   1              {
 147   2                      ret = s_tKey.Buf[s_tKey.Read];
 148   2      
 149   2                      if (++s_tKey.Read >= KEY_FIFO_SIZE)
 150   2                      {
 151   3                              s_tKey.Read = 0;
 152   3                      }
 153   2                      return ret;
 154   2              }
 155   1      }
 156          
 157          void bsp_InitKeyVar(void)
 158          {
 159   1              unsigned char i;
 160   1      
 161   1              /* 对按键FIFO读写指针清零 */
 162   1              s_tKey.Read = 0;
 163   1              s_tKey.Write = 0;
 164   1      //      s_tKey.Read2 = 0;
 165   1      
 166   1              /* 给每个按键结构体成员变量赋一组缺省值 */
 167   1              for (i = 0; i < KEY_COUNT; i++)
 168   1              {
 169   2                      s_tBtn[i].LongTime = KEY_LONG_TIME;                     /* 长按时间 0 表示不检测长按键事件 */
 170   2                      s_tBtn[i].Count = KEY_FILTER_TIME / 2;          /* 计数器设置为滤波时间的一半 */
 171   2                      s_tBtn[i].State = 0;                                                    /* 按键缺省状态，0为未按下 */
 172   2                      s_tBtn[i].RepeatSpeed = 0;                                              /* 按键连发的速度，0表示不支持连发 */
 173   2                      s_tBtn[i].RepeatCount = 0;                                              /* 连发计数器 */
 174   2              }
 175   1              s_tBtn[0].IsKeyDownFunc = IsKeyDown1;
 176   1              s_tBtn[1].IsKeyDownFunc = IsKeyDown2;
 177   1      }
 178          
C51 COMPILER V9.60.0.0   BSP_KEY                                                           11/18/2022 17:04:36 PAGE 4   

 179          
 180          
 181          static void bsp_DetectKey(unsigned char i)
 182          {
 183   1              KEY_T *pBtn;
 184   1      
 185   1              
 186   1                      if (s_tBtn[i].IsKeyDownFunc == 0)
 187   1                      {
 188   2                              //printf("Fault : DetectButton(), s_tBtn[i].IsKeyDownFunc undefine");
 189   2                      }
 190   1              
 191   1      
 192   1              pBtn = &s_tBtn[i];
 193   1              if (pBtn->IsKeyDownFunc())
 194   1              {
 195   2                      if (pBtn->Count < KEY_FILTER_TIME)
 196   2                      {
 197   3                              pBtn->Count = KEY_FILTER_TIME;
 198   3                      }
 199   2                      else if(pBtn->Count < 2 * KEY_FILTER_TIME)
 200   2                      {
 201   3                              pBtn->Count++;
 202   3                      }
 203   2                      else
 204   2                      {
 205   3                              if (pBtn->State == 0)
 206   3                              {
 207   4                                      pBtn->State = 1;
 208   4      
 209   4                                      /* 发送按钮按下的消息 */
 210   4                                      bsp_PutKey((unsigned char)(3 * i + 1));
 211   4                              }
 212   3      
 213   3                              if (pBtn->LongTime > 0)
 214   3                              {
 215   4                                      if (pBtn->LongCount < pBtn->LongTime)
 216   4                                      {
 217   5                                              /* 发送按钮持续按下的消息 */
 218   5                                              if (++pBtn->LongCount == pBtn->LongTime)
 219   5                                              {
 220   6                                                      /* 键值放入按键FIFO */
 221   6                                                      bsp_PutKey((unsigned char)(3 * i + 3));
 222   6                                              }
 223   5                                      }
 224   4                                      else
 225   4                                      {
 226   5                                              if (pBtn->RepeatSpeed > 0)
 227   5                                              {
 228   6                                                      if (++pBtn->RepeatCount >= pBtn->RepeatSpeed)
 229   6                                                      {
 230   7                                                              pBtn->RepeatCount = 0;
 231   7                                                              /* 常按键后，每隔10ms发送1个按键 */
 232   7                                                              bsp_PutKey((unsigned char)(3 * i + 1));
 233   7                                                      }
 234   6                                              }
 235   5                                      }
 236   4                              }
 237   3                      }
 238   2              }
 239   1              else
 240   1              {
C51 COMPILER V9.60.0.0   BSP_KEY                                                           11/18/2022 17:04:36 PAGE 5   

 241   2                      if(pBtn->Count > KEY_FILTER_TIME)
 242   2                      {
 243   3                              pBtn->Count = KEY_FILTER_TIME;
 244   3                      }
 245   2                      else if(pBtn->Count != 0)
 246   2                      {
 247   3                              pBtn->Count--;
 248   3                      }
 249   2                      else
 250   2                      {
 251   3                              if (pBtn->State == 1)
 252   3                              {
 253   4                                      pBtn->State = 0;
 254   4      
 255   4                                      /* 发送按钮弹起的消息 */
 256   4                                      bsp_PutKey((unsigned char)(3 * i + 2));
 257   4                              }
 258   3                      }
 259   2      
 260   2                      pBtn->LongCount = 0;
 261   2                      pBtn->RepeatCount = 0;
 262   2              }
 263   1      }
 264          
 265          void bsp_KeyScan(void)
 266          {
 267   1              unsigned char i;
 268   1      
 269   1              for (i = 0; i < KEY_COUNT; i++)
 270   1              {
 271   2                      bsp_DetectKey(i);
 272   2              }
 273   1      }
 274          
 275          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    832    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     40       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
